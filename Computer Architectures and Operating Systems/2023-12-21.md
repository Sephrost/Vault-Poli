#### Memory management
Programs must first be loaded to the main memory to be run.

> Recall that registers and main memory are the only storage that the CPU can access directly.
>
>While register access is fast(1 clock cycle), main memory access is slower(2 or more), causing a stall.

Faster memory are preferable, but expensive, to balance cost with speed, a memory hierarchy is used.

![[Pasted image 20230430122536.png|550]]

The main memory is divided in two portion:
- a part reserved for the resident operating system, located in the low memory portion, with the interrupt vector
- a part reserved for the user processes

In any given moment, its likely that more than one process in running on the system. To ensure that a process can access only the addresses that is allowed to, we limit its accessible memory area with a base and limit register, to define its logical address space.
Thus, CPU must check every memory access to ensure that is allowed(in between the base and the limit). The instructions to load the base and limit are actually privileged.
#### Logical and physical addresses
To abstract the physical memory management, two kinds of addresses are used:
- **logical addresses**: generated by the CPU
- **physical addresses**: the actually addresses seen by the memory unit

Logical an physical are the same at compile and load time, and only differ from one another at runtime, mapping an address of one kind the another.

The mapping and the lookups are managed by the **memory-management unit**.

### Static partitioning
Static partitioning divides the main memory into a set of non-overlapping regions called **partition**. A partition configuration is done at compile time and cannot change over time.

> The size of a partition can be fixed, or not.

Partitioning can cause **internal fragmentation**, which is the waste of unused memory assigned to a program.

Memory assignment of partition is actually pretty easy: if there's a available segment in the memory it is assigned. If all are occupied, one is swapped out to make space for the new one.
#### Variable partitioning
To avoid internal fragmentation, it is possible to allow variable-size partitions for memory efficiency, allocating only the required space to a given program. 

In this kind of memory management, we call available block of memory **holes**. When a process has to be executed, the CPU allocates to it the memory from a hole large enough to accommodate it.

When a process terminate, the CPU frees its partition, combining it with the adjacent holes

This comes to some degree of overhead: the os has to keep trace of allocated partitions and holes positions.